# Copyright 2013 <chaishushan{AT}gmail.com>. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

# -----------------------------------------------------------------------------

Go语言并发编程

chai2010
chaishushan@gmail.com
https://github.com/chai2010

# -----------------------------------------------------------------------------

* 自我介绍(chai2010)

- [[https://golang.org/CONTRIBUTORS][Go语言代码贡献者]]
- [[https://github.com/golang-china/gopl-zh][Go语言圣经]]翻译者
- [[https://github.com/golang-china][Go语言中文文档]]翻译者
- [[https://groups.google.com/forum/#!forum/golang-china][golang-china]] 邮件列表初始创建者和维护者
- [[https://code.google.com/p/go/source/browse/misc/notepadplus/README][notepad++]]等功能的完善和实现([[https://code.google.com/p/go/source/browse/misc/notepadplus/userDefineLang.xml][语法高亮]]/[[https://code.google.com/p/go/source/browse/misc/notepadplus/go.xml][内建函数自动补全]]/[[https://code.google.com/p/go/source/browse/misc/notepadplus/functionList.xml][函数列表]]等)
- Github: [[https://github.com/chai2010][https://github.com/chai2010]]
- QQ群: 102319854

.image chai2010-golang-concurrency/frontpage.png


# -----------------------------------------------------------------------------
* 你好, 并发!
# -----------------------------------------------------------------------------

* 并发很简单

.play chai2010-golang-concurrency/hello.go /package main/,

- go关键字启动一个Goroutine
- 请分析程序的运行状态

* 解决并发中的小问题

.play chai2010-golang-concurrency/hello-v2.go /package main/,

- 请分析程序的运行状态
- time.Sleep 的作用?

* WTF! Go语言的并发真的是弱爆了!

.play chai2010-golang-concurrency/hello-v3.go /func main/,

- 请分析程序的运行状态

* 并发小问题分析

前面代码运行有一定的随机性, 无法保证并发程序的正确运行.

并发的几个原则:

- go启动goroutine时无法保证新线程马上运行
- main退出时程序退出

解决的思路:

- 后台gotoutine完成之前main函数不能退出.

* 暴力一点: 不要让main函数退出!

.play chai2010-golang-concurrency/hello-v4.go /func main/,

- 后台的打印工作可以保证完成(有问题吗?)
- main 函数永远不会退出(没问题)


* 见了鬼了: main函数居然占着茅坑不拉屎!

.play chai2010-golang-concurrency/hello-v5.go /func main/,

- `for {}` 死循环保证了main函数不会退出, 但是依然占用了 CPU 资源
- 当只有一个系统线程资源时, main 将独占CPU, 其它线程被饿死

* 让不拉屎的main函数先站在茅坑边上等着!

.play chai2010-golang-concurrency/hello-v6.go /func main/,

- `select {}` 保证了main函数不会退出, 不占用了 CPU 资源
- 即使只有一个系统线程资源时, 后台线程依然有机会执行

* 虐待main函数的方法当然不止一种...

.play chai2010-golang-concurrency/hello-v7.go /func main/,

- `<-make(chan int)` 保证了main函数不会退出, 不占用了 CPU 资源
- 即使只有一个系统线程资源时, 后台线程依然有机会执行

* 崩溃: 居然都不拉屎了 - 阻塞导致死锁异常

.play chai2010-golang-concurrency/hello-v8.go /func main/,

- main 因为阻塞导致永远不会退出
- 没有其它可运行的goroutine导致异常

注意:

- `for {}` 死循环并不会导致死锁异常

* 要做好Goroutine的善后工作

.play chai2010-golang-concurrency/hello-v9.go /func main/,

- main 函数阻塞
- 直到 done 管道有数据
- 当 done 管道有数据时, 后台 Goroutine 必然已经完成工作
- 完美的并发!

* 充分利用并发资源

.play chai2010-golang-concurrency/hello-v10.go /func main/,

- 充分利用了系统的并发资源
- 输出顺序有一定的随机性
- main退出时工作全部完成

* 充分利用sync标准库

.play chai2010-golang-concurrency/hello-v11.go /func main/,

- sync.WaitGroup 用于等待一组并发体完成

# -----------------------------------------------------------------------------
* 并发的内存模型
# -----------------------------------------------------------------------------

* 原子操作

- 最小的且不可并行化 的操作
- 保证共享资源的完整性, 避免出现完成一半的状态
- sync/atomic 对数值类型/指针 等提供原子读写支持
- sync.Mutex 也可以封装自己的原子操作

* 顺序一致性内存模型

	var msg string
	var done bool = false

	func main() {
		msg = "hello, world"
		done = true
	}

- msg 和 done 哪个先完成赋值要看具体场景!
- msg 和 done 是否能够完成赋值也要看具体场景!
- msg 和 done 赋值的顺序和代码书写的顺序并不等价!

* 同一个Goroutine内: 满足顺序一致性内存模型

	var msg string
	var done bool = false

	func main() {
		msg = "hello, world"
		done = true

		for {
			if done {
				println(msg)
				break
			}
		}
	}

- 先设置 msg 字符串, 然后设置 done 标志
- 那么, 如果 done 标志为 true, msg 必然已经完成初始化
- 如果 msg 完成了初始化, 那么打印并退出程序
- 单线程是 OK

* 不同Goroutine之间: 不满足顺序一致性!

	var msg string
	var done bool = false

	func main() {
		go func() {
			msg = "hello, world"
			done = true
		}()

		for {
			if done {
				println(msg)
				break
			}
		}
	}

- main线程可能无法看到后台线程对msg和done做的更新
- msg 的修改不是原子操作, main可能看到被修改一半的数据
- 多线程环境, 程序结果未知

* 通过Channel设置时间参考

	var msg string
	var done = make(chan bool)

	func main() {
		go func() {
			msg = "hello, world"
			done <- true
		}()

		<-done
		println(msg)
	}

- done管道的发送和接收会强制进行一次同步
- 此刻, 后台线程内, 满足顺序一致性内存模型, 字符串完成初始化
- 此刻, main线程通过同步, 分享到后台线程此刻的字符串状态
- 然后, main打印出了初始化之后的字符串

* 通过sync.Mutex设置时间参考

	var msg string
	var done sync.Mutex

	func main() {
		done.Lock()
		go func() {
			msg = "hello, world"
			done.Unlock()
		}()

		done.Lock()
		println(msg)
	}

- sync.Mutex也是设置时间参考
- 但是, 代码可读性没有管道好

* 带缓存的管道可控制并发数

	var limit = make(chan int, 3)

	func main() {
		for _, w := range work {
			go func() {
				limit <- 1
				w()
				<-limit
			}()
		}
		select{}
	}

- 并发程序不仅仅是要运行的更快
- 关键是要并发层度可控!
- 散步时就要慢一点...

* 初始化顺序

.image chai2010-golang-concurrency/init.png

- 进入 main 函数之前, 只有一个Goroutine运行
- 进入 main 函数之后, 在 init 中启动的 Goroutine 可能会被执行


* Goroutine特点

- 由go关键字启动, 是一种轻量级的线程
- 以一个很小的栈启动(可能是2KB/4KB), 可以启动很多
- Goroutine栈的大小会根据需要动态地伸缩, 不用担心栈溢出
- m个goroutine运行在n个操作系统线程上, n默认对应CPU核数
- runtime.GOMAXPROCS用于控制当前运行运行正常非阻塞Goroutine的系统线程数目
- 发生在用户态, 切换的代价要比系统线程低(切换时只需要保存必要的寄存器)
- Goroutine采用的是半抢占式的协作调度(在函数入口处插入协作代码)
- IO/sleep/runtime.Gosched 均会导致调度


# -----------------------------------------------------------------------------
* 常见的并发模式
# -----------------------------------------------------------------------------

# Once 代码分析

# 素数筛

# -----------------------------------------------------------------------------
# END
# -----------------------------------------------------------------------------


# -----------------------------------------------------------------------------
# END
# -----------------------------------------------------------------------------




