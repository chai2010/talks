<!DOCTYPE html>
<html>
  <head>
    <title>Go语言并发编程</title>
    <meta charset='utf-8'>
    <script>
      var notesEnabled =  false ;
    </script>
    <script src='./static/slides.js'></script>


    <script>

      if (window["location"] && window["location"]["hostname"] == "talks.golang.org") {
        var _gaq = _gaq || [];
        _gaq.push(["_setAccount", "UA-11222381-6"]);
        _gaq.push(["b._setAccount", "UA-49880327-6"]);
        window.trackPageview = function() {
          _gaq.push(["_trackPageview", location.pathname+location.hash]);
          _gaq.push(["b._trackPageview", location.pathname+location.hash]);
        };
        window.trackPageview();
        window.trackEvent = function(category, action, opt_label, opt_value, opt_noninteraction) {
          _gaq.push(["_trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
          _gaq.push(["b._trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
        };
      }
    </script>
  </head>

  <body style='display: none'>

    <section class='slides layout-widescreen'>

      <article>
        <h1>Go语言并发编程</h1>



          <div class="presenter">


  <p>
    柴树杉(chaishushan{AT}gmail.com)
  </p>


          </div>

          <div class="presenter">


  <p>

  </p>


          </div>

      </article>



      <article >

        <h3>自我介绍(chai2010)</h3>

  <ul>

    <li>Go语言圣经 <a href="https://github.com/golang-china/gopl-zh" target="_blank">翻译者</a></li>

    <li>Go语言代码 <a href="https://golang.org/CONTRIBUTORS" target="_blank">贡献者</a></li>

    <li>Github: <a href="https://github.com/chai2010" target="_blank">https://github.com/chai2010</a></li>

    <li>QQ群: 102319854</li>

  </ul>


  <p>
    个人签名:
  </p>


  <ul>

    <li>当歌曲、传说和建筑都已经缄默的时候，只有代码还在说话! - by chai2010</li>

    <li>Less is more!</li>

  </ul>

<div class="image">
  <img src="./images/frontpage.png">
</div>


      </article>



      <article >

        <h2>Go语言并发哲学</h2>

      </article>



      <article >

        <h3>Go语言并发哲学</h3>


  <p>
    Do not communicate by sharing memory, instead, share memory by communicating!
  </p>



  <p>
    不要通过共享内存来通信, 而是通过通信来共享内存!
  </p>



  <p>
    不要逆行!
  </p>



      </article>



      <article >

        <h2>并发的演化历史</h2>

      </article>



      <article >

        <h3>语言演化历史</h3>

<div class="image">
  <img src="./images/go-history.png">
</div>

  <ul>

    <li><a href="http://en.wikipedia.org/wiki/B_(programming_language)" target="_blank">B</a> - Ken Thompson, 1969</li>

    <li><a href="http://en.wikipedia.org/wiki/C_(programming_language)" target="_blank">C</a> - Dennis Ritchie, 1972</li>

    <li><a href="http://en.wikipedia.org/wiki/Newsqueak" target="_blank">Newsqueak</a> - Rob Pike, 1989, GUI</li>

    <li><a href="http://en.wikipedia.org/wiki/Alef_(programming_language)" target="_blank">Alef</a> - Phil Winterbottom, 1993, <b>C-like</b></li>

    <li><a href="http://en.wikipedia.org/wiki/Limbo_(programming_language)" target="_blank">Limbo</a> - Sean Dorward, Phil Winterbottom, Rob Pike,1995</li>

    <li><a href="http://golang.org/" target="_blank">Go</a> - 2009, <b>C-like</b></li>

  </ul>


      </article>



      <article >

        <h3>理论基础</h3>

  <ul>

    <li><a href="http://coolshell.cn/articles/1351.html" target="_blank">管道</a> - Malcolm Douglas McIlroy, 1964</li>

    <li><a href="http://en.wikipedia.org/wiki/Communicating_sequential_processes" target="_blank">CSP</a> - C. A. R. Hoare, 1978</li>

  </ul>


  <p>
    相关历史:
  </p>


  <ul>

    <li><a href="https://swtch.com/~rsc/thread/" target="_blank">Bell Labs and CSP Threads</a> - Russ Cox</li>

  </ul>


      </article>



      <article >

        <h3>Newsqueak素数筛(01) - Rob Pike, 1989</h3>

  <div class="code" >


<pre><span num="2"><b>counter := prog(c:chan of int) {</b></span>
<span num="3">    i:=2;</span>
<span num="4">    for(;;)</span>
<span num="5">        <b>c &lt;-= i&#43;&#43;;</b></span>
<span num="6">};</span>
</pre>


</div>

  <div class="code" >


<pre><span num="8"><b>filter := prog(prime:int, listen, send:chan of int) {</b></span>
<span num="9">    i:int;</span>
<span num="10">    for(;;)</span>
<span num="11">        if((i = &lt;-listen)%prime)</span>
<span num="12">            <b>send &lt;-= i;</b></span>
<span num="13">};</span>
</pre>


</div>

<div class="image">
  <img src="./images/spaceglenda37.png" height="250" width="1000">
</div>


      </article>



      <article >

        <h3>Newsqueak素数筛(02) - Rob Pike, 1989</h3>

  <div class="code" >


<pre><span num="16">sieve := prog() of chan of int {</span>
<span num="17">    <b>c := mk(chan of int);</b></span>
<span num="18">    <b>begin counter(c);</b></span>
<span num="19">    prime := mk(chan of int);</span>
<span num="20">    <b>begin prog(){</b></span>
<span num="21">        p:int;</span>
<span num="22">        newc:chan of int;</span>
<span num="23">        for(;;){</span>
<span num="24">            prime &lt;-= p =&lt;- c;</span>
<span num="25">            newc = mk();</span>
<span num="26">            <b>begin filter(p, c, newc);</b></span>
<span num="27">            c = newc;</span>
<span num="28">        }</span>
<span num="29">    }();</span>
<span num="30">    <b>become prime;</b></span>
<span num="31">};</span>
<span num="32"></span>
<span num="33">prime:=sieve();</span>
</pre>


</div>

  <ul>

    <li>begin 启动一个并发, 类似 go 关键字</li>

    <li>become 返回值, 类似 return 关键字</li>

  </ul>


      </article>



      <article >

        <h3>Newsqueak素数筛(03) - 原理</h3>

<div class="image">
  <img src="./images/prime-sieve.png" height="500" width="1000">
</div>


      </article>



      <article >

        <h3>Alef(01) - Phil Winterbottom, 1993</h3>

  <div class="code" >


<pre><span num="1">#include &lt;alef.h&gt;</span>
<span num="2"></span>
<span num="3"><b>void receive(chan(byte*) c) {</b></span>
<span num="4">    byte *s;</span>
<span num="5">    <b>s = &lt;- c;</b></span>
<span num="6">    print(&#34;%s\n&#34;, s);</span>
<span num="7">    <b>terminate(nil);</b></span>
<span num="8">}</span>
<span num="9"></span>
<span num="10">void main(void) {</span>
<span num="11">    <b>chan(byte*) c;</b></span>
<span num="12">    alloc c;</span>
<span num="13">    <b>proc receive(c);</b></span>
<span num="14">    <b>task receive(c);</b></span>
<span num="15">    <b>c &lt;- = &#34;hello proc or task&#34;;</b></span>
<span num="16">    <b>c &lt;- = &#34;hello proc or task&#34;;</b></span>
<span num="17">    print(&#34;done\n&#34;);</span>
<span num="18">    <b>terminate(nil);</b></span>
<span num="19">}</span>
</pre>


</div>

  <ul>

    <li>proc 启动一个进程</li>

    <li>task 启动一个线程</li>

  </ul>


      </article>



      <article >

        <h3>Alef(02) - Phil Winterbottom, 1993</h3>

<div class="image">
  <img src="./images/alef.png">
</div>


  <p>
    Alef 同时支持进程和线程, 是伪装成编程语言的操作系统!
  </p>



      </article>



      <article >

        <h2>你好, 并发!</h2>

      </article>



      <article >

        <h3>并发很简单</h3>


  <div class="code"><pre>// 普通版本
func main() {
    println(&#34;你好, 并发!&#34;)
}

// 并发版本
func main() {
    go println(&#34;你好, 并发!&#34;)
}</pre></div>


  <ul>

    <li>go 关键字调用函数</li>

  </ul>


      </article>



      <article >

        <h3>Go的并发好强大</h3>


  <div class="code"><pre>func main() {
    for {
        go stackoverflow()
    }
}

func stackoverflow() {
    stackoverflow()
}</pre></div>


  <ul>

    <li>每个 Goroutine <b>栈很小</b>, 切换代价很低, 可以海量并发</li>

    <li>每个 Goroutine <b>栈很大</b>, 没有逻辑限制, 可以无限递归</li>

    <li>横向和纵向都可以无限扩展(只受资源限制)</li>

  </ul>


      </article>



      <article >

        <h3>并发中的小问题(01): 没事走两步~</h3>

  <div class="code" >


<pre><span num="3">package main</span>
<span num="4"></span>
<span num="5">func main() {</span>
<span num="6">    <b>go println(&#34;你好, 并发!&#34;)</b></span>
<span num="7">}</span>
</pre>


</div>

  <ul>

    <li>go关键字启动一个Goroutine</li>

    <li>请分析程序的运行状态</li>

  </ul>


      </article>



      <article >

        <h3>并发中的小问题(02)</h3>

  <div class="code" >


<pre><span num="3">package main</span>
<span num="4"></span>
<span num="5">import &#34;time&#34;</span>
<span num="6"></span>
<span num="7">func main() {</span>
<span num="8">    go println(&#34;你好, 并发!&#34;)</span>
<span num="9">    <b>time.Sleep(time.Second)</b></span>
<span num="10">}</span>
</pre>


</div>

  <ul>

    <li>请分析程序的运行状态</li>

    <li>time.Sleep 的作用?</li>

  </ul>


      </article>



      <article >

        <h3>解决并发中的小问题(03)</h3>

  <div class="code" >


<pre><span num="3">package main</span>
<span num="4"></span>
<span num="5">import &#34;time&#34;</span>
<span num="6"></span>
<span num="7">func main() {</span>
<span num="8">    go println(&#34;你好, 并发!&#34;)</span>
<span num="9">    <b>time.Sleep(time.Second)</b></span>
<span num="10">}</span>
<span num="11"></span>
<span num="12"><b>func println(s string) {</b></span>
<span num="13">    <b>time.Sleep(time.Second*2)</b></span>
<span num="14">    print(s&#43;&#34;\n&#34;)</span>
<span num="15">}</span>
</pre>


</div>

  <ul>

    <li>很不幸, println 内部足足睡眠了 2 秒钟 !</li>

  </ul>


      </article>



      <article >

        <h3>WTF: Go语言并发真的是弱爆了(小问题并不容易解决)!</h3>

  <div class="code" >


<pre><span num="10">func main() {</span>
<span num="11">    <b>go func() {</b></span>
<span num="12">        <b>for i := 0; ; i&#43;&#43; {</b></span>
<span num="13">            <b>fmt.Println(i)</b></span>
<span num="14">        <b>}</b></span>
<span num="15">    <b>}()</b></span>
<span num="16"></span>
<span num="17">    time.Sleep(time.Second)</span>
<span num="18">}</span>
</pre>


</div>

  <ul>

    <li>更不幸的情况, 直接霸道地不返回了</li>

    <li>即使 time.Sleep 一万年也没辙</li>

  </ul>


      </article>



      <article >

        <h3>并发小问题分析</h3>


  <p>
    前面代码运行有一定的随机性, 无法保证并发程序的正确运行.
  </p>



  <p>
    并发的几个原则:
  </p>


  <ul>

    <li>go启动Goroutine时无法保证新线程马上运行</li>

    <li>main退出时程序退出</li>

  </ul>


  <p>
    解决的思路:
  </p>


  <ul>

    <li>后台Goroutine完成之前main函数不能退出.</li>

  </ul>


      </article>



      <article >

        <h3>暴力一点: 不要让main函数退出!</h3>

  <div class="code" >


<pre><span num="9">func main() {</span>
<span num="10">    go func() {</span>
<span num="11">        for i := 0; ; i&#43;&#43; {</span>
<span num="12">            fmt.Println(i)</span>
<span num="13">        }</span>
<span num="14">    }()</span>
<span num="15"></span>
<span num="16">    <b>for {} // 死循环是大杀器</b></span>
<span num="17">}</span>
</pre>


</div>

  <ul>

    <li>后台的打印工作可以保证完成(有问题吗?)</li>

    <li>main 函数永远不会退出(没问题)</li>

  </ul>


      </article>



      <article >

        <h3>存在问题: main函数居然独占了系统线程!</h3>

  <div class="code" >


<pre><span num="10">func main() {</span>
<span num="11">    <b>runtime.GOMAXPROCS(1)</b></span>
<span num="12"></span>
<span num="13">    go func() {</span>
<span num="14">        for i := 0; ; i&#43;&#43; {</span>
<span num="15">            fmt.Println(i)</span>
<span num="16">        }</span>
<span num="17">    }()</span>
<span num="18"></span>
<span num="19">    <b>for {} // 占用CPU</b></span>
<span num="20">}</span>
</pre>


</div>

  <ul>

    <li>`for {}` 死循环保证了main函数不会退出, 但是依然占用了 系统线程</li>

    <li>当只有一个系统线程资源时, main 将独占活跃的 系统线程, 其它线程被饿死</li>

    <li>活跃的 系统线程 是有限的资源</li>

  </ul>


      </article>



      <article >

        <h3>独占系统线程的原因: Goroutine是协作式调度</h3>

  <div class="code" >


<pre><span num="11">func main() {</span>
<span num="12">    <b>runtime.GOMAXPROCS(1)</b></span>
<span num="13"></span>
<span num="14">    <b>go func() { for {} }()</b></span>
<span num="15"></span>
<span num="16">    time.Sleep(time.Second)</span>
<span num="17"></span>
<span num="18">    <b>fmt.Println(&#34;the answer to life:&#34;, 42)</b></span>
<span num="19">}</span>
</pre>


</div>

  <ul>

    <li>只是在编译后的每个函数入口被插入一次调度(类似的还有栈管理的函数等)</li>

    <li>runtime 无法强制剥夺纯计算型 Goroutine 的运行</li>

  </ul>


      </article>



      <article >

        <h3>避免让不干活的main函数独占了系统线程</h3>

  <div class="code" >


<pre><span num="10">func main() {</span>
<span num="11">    <b>runtime.GOMAXPROCS(1)</b></span>
<span num="12"></span>
<span num="13">    go func() {</span>
<span num="14">        for i := 0; ; i&#43;&#43; {</span>
<span num="15">            fmt.Println(i)</span>
<span num="16">        }</span>
<span num="17">    }()</span>
<span num="18"></span>
<span num="19">    <b>select{} // 阻塞, 不占用CPU</b></span>
<span num="20">}</span>
</pre>


</div>

  <ul>

    <li>`select {}` 保证了main函数不会退出, 不再独占 系统线程 资源</li>

    <li>即使只有一个系统线程资源时, 后台线程依然有机会执行</li>

  </ul>


      </article>



      <article >

        <h3>虐待main函数的方法当然不止一种...</h3>

  <div class="code" >


<pre><span num="10">func main() {</span>
<span num="11">    <b>runtime.GOMAXPROCS(1)</b></span>
<span num="12"></span>
<span num="13">    go func() {</span>
<span num="14">        for i := 0; ; i&#43;&#43; {</span>
<span num="15">            fmt.Println(i)</span>
<span num="16">        }</span>
<span num="17">    }()</span>
<span num="18"></span>
<span num="19">    <b>&lt;-make(chan int) // 阻塞, 不占用CPU</b></span>
<span num="20">}</span>
</pre>


</div>

  <ul>

    <li>`&lt;-make(chan int)` 保证了main函数不会退出, 不再独占 系统线程 资源</li>

    <li>即使只有一个系统线程资源时, 后台线程依然有机会执行</li>

  </ul>


      </article>



      <article >

        <h3>崩溃: 居然都不干活了 - 阻塞导致死锁异常</h3>

  <div class="code" >


<pre><span num="5">func main() {</span>
<span num="6">    <b>go println(&#34;你好, 并发!&#34;)</b></span>
<span num="7">    <b>&lt;-make(chan int) // 阻塞, 不占用CPU</b></span>
<span num="8">}</span>
</pre>


</div>

  <ul>

    <li>main 因为阻塞导致永远不会退出</li>

    <li>没有其它可运行的goroutine导致异常</li>

    <li>操作系统中如果没有任何一个进程在运行会是什么样子?</li>

  </ul>


  <p>
    注意:
  </p>


  <ul>

    <li>`for {}` 死循环并不会导致死锁异常</li>

  </ul>


      </article>



      <article >

        <h3>有人干活, 有人偷懒</h3>

  <div class="code" >


<pre><span num="9">func main() {</span>
<span num="10">    go println(&#34;你好, 并发!&#34;) // 干活的</span>
<span num="11"></span>
<span num="12">    <b>go func() { &lt;-make(chan int) } () // 滥竽充数的, Goroutine 泄露</b></span>
<span num="13">    <b>go func() { for{} } () // 浪费资源的, 但不是 Goroutine 泄露</b></span>
<span num="14">    <b>go func() {} () // 滥竽充数的, 但不是 Goroutine 泄露</b></span>
<span num="15"></span>
<span num="16">    time.Sleep(time.Second)</span>
<span num="17">    println(&#34;Done&#34;)</span>
<span num="18">}</span>
</pre>


</div>

  <ul>

    <li>不干活和浪费资源都不可取</li>

    <li>要劳逸结合</li>

  </ul>


      </article>



      <article >

        <h3>要做好Goroutine的善后工作</h3>

  <div class="code" >


<pre><span num="5">func main() {</span>
<span num="6">    <b>done := make(chan bool)</b></span>
<span num="7">    go func() {</span>
<span num="8">        println(&#34;你好, 并发!&#34;)</span>
<span num="9">        <b>done &lt;- true</b></span>
<span num="10">    }()</span>
<span num="11"></span>
<span num="12">    <b>&lt;-done</b></span>
<span num="13">}</span>
</pre>


</div>

  <ul>

    <li>main 函数阻塞, 直到 done 管道有数据</li>

    <li>当 done 管道有数据时, 后台 Goroutine 必然已经完成了打印工作</li>

    <li>Goroutine 何时退出并不关心, 重点是工作已经完成了</li>

    <li>完美的并发!</li>

  </ul>


      </article>



      <article >

        <h3>充分利用并发资源</h3>

  <div class="code" >


<pre><span num="5">func main() {</span>
<span num="6">    const N = 10</span>
<span num="7">    <b>done := make(chan bool, N)</b></span>
<span num="8"></span>
<span num="9">    for i := 0; i &lt; N; i&#43;&#43; {</span>
<span num="10">        go func(i int) {</span>
<span num="11">            println(i, &#34;你好, 并发!&#34;)</span>
<span num="12">            <b>done &lt;- true</b></span>
<span num="13">        }(i)</span>
<span num="14">    }</span>
<span num="15"></span>
<span num="16">    for i := 0; i &lt; N; i&#43;&#43; {</span>
<span num="17">        <b>&lt;-done</b></span>
<span num="18">    }</span>
<span num="19">}</span>
</pre>


</div>

  <ul>

    <li>充分利用了系统的并发资源</li>

    <li>输出顺序有一定的随机性</li>

    <li>main退出时全部 <b>打印工作</b> 完成, 但 <b>无法保证Goroutine全部退出</b></li>

  </ul>


      </article>



      <article >

        <h3>充分利用sync标准库</h3>

  <div class="code" >


<pre><span num="7">func main() {</span>
<span num="8">    const N = 10</span>
<span num="9">    <b>var wg sync.WaitGroup</b></span>
<span num="10"></span>
<span num="11">    for i := 0; i &lt; N; i&#43;&#43; {</span>
<span num="12">        <b>wg.Add(1) // 必须在 go 语句前调用!</b></span>
<span num="13">        go func(i int) {</span>
<span num="14">            <b>defer wg.Done()</b></span>
<span num="15">            println(i, &#34;你好, 并发!&#34;)</span>
<span num="16">        }(i)</span>
<span num="17">    }</span>
<span num="18"></span>
<span num="19">    <b>wg.Wait()</b></span>
<span num="20">}</span>
</pre>


</div>

  <ul>

    <li>sync.WaitGroup 用于等待一组并发体完成</li>

  </ul>


      </article>



      <article >

        <h3>小心闭包陷阱</h3>

  <div class="code" >


<pre><span num="7">func main() {</span>
<span num="8">    for i := 0; i &lt; 10; i&#43;&#43; {</span>
<span num="9">        <b>go func() { println(i) }() // 对比多次执行结果</b></span>
<span num="10">    }</span>
<span num="11">    time.Sleep(time.Second)</span>
<span num="12">}</span>
</pre>


</div>

  <div class="code" >


<pre><span num="7">func main() {</span>
<span num="8">    for i := 0; i &lt; 10; i&#43;&#43; {</span>
<span num="9">        <b>go func(i int) { println(i) }(i) // 函数参数是传值</b></span>
<span num="10">    }</span>
<span num="11">    time.Sleep(time.Second)</span>
<span num="12">}</span>
</pre>


</div>

  <div class="code" >


<pre><span num="7">func main() {</span>
<span num="8">    for i := 0; i &lt; 10; i&#43;&#43; {</span>
<span num="9">        <b>i := i // 定义新的局部变量, 每次迭代都不同</b></span>
<span num="10">        go func() { println(i) }()</span>
<span num="11">    }</span>
<span num="12">    time.Sleep(time.Second)</span>
<span num="13">}</span>
</pre>


</div>


      </article>



      <article >

        <h2>并发的内存模型</h2>

      </article>



      <article >

        <h3>原子操作</h3>

  <ul>

    <li>最小的且不可并行化 的操作</li>

    <li>保证共享资源的完整性, 避免出现完成一半的状态</li>

    <li>sync/atomic 对数值类型/指针 等提供原子读写支持</li>

    <li>sync.Mutex 也可以封装自己的原子操作</li>

  </ul>


  <p>
    <b>只有原子操作并不能保证写出正确的并发程序！</b>
  </p>



      </article>



      <article >

        <h3>顺序一致性内存模型</h3>

  <div class="code" >


<pre><span num="3">package main</span>
<span num="4"></span>
<span num="5">var msg string</span>
<span num="6">var done bool = false</span>
<span num="7"></span>
<span num="8">func main() {</span>
<span num="9">    msg = &#34;hello, world&#34;</span>
<span num="10">    done = true</span>
<span num="11">}</span>
</pre>


</div>

  <ul>

    <li>msg 和 done 哪个先完成赋值要看具体场景!</li>

    <li>msg 和 done 是否能够完成赋值也要看具体场景!</li>

    <li>msg 和 done 赋值的顺序和代码书写的顺序并不等价!</li>

  </ul>


  <p>
    <b>原子操作配合一致性内存模型就可以写出正确的并发程序！</b>
  </p>



      </article>



      <article >

        <h3>同一个Goroutine内: 满足顺序一致性内存模型</h3>

  <div class="code" >


<pre><span num="5">var msg string</span>
<span num="6">var done bool = false</span>
<span num="7"></span>
<span num="8">func main() {</span>
<span num="9">    msg = &#34;hello, world&#34;</span>
<span num="10">    done = true</span>
<span num="11"></span>
<span num="12">    for {</span>
<span num="13">        <b>if done {</b></span>
<span num="14">            println(msg)</span>
<span num="15">            break</span>
<span num="16">        }</span>
<span num="17">        println(&#34;retry...&#34;)</span>
<span num="18">    }</span>
<span num="19">}</span>
</pre>


</div>

  <ul>

    <li>先设置 msg 字符串, 然后设置 done 标志</li>

    <li>那么, 如果 done 标志为 true, msg 必然已经完成初始化</li>

    <li>如果 msg 完成了初始化, 那么打印并退出程序</li>

    <li>单线程是 OK</li>

  </ul>


      </article>



      <article >

        <h3>不同Goroutine之间: 不满足顺序一致性!</h3>

  <div class="code" >


<pre><span num="9">var msg string</span>
<span num="10">var done bool = false</span>
<span num="11"></span>
<span num="12">func main() {</span>
<span num="13">    <b>runtime.GOMAXPROCS(2)</b></span>
<span num="14"></span>
<span num="15">    go func() {</span>
<span num="16">        msg = &#34;hello, world&#34;</span>
<span num="17">        <b>done = true</b></span>
<span num="18">    }()</span>
<span num="19"></span>
<span num="20">    for {</span>
<span num="21">        <b>if done {</b></span>
<span num="22">            println(msg); break</span>
<span num="23">        }</span>
<span num="24">        println(&#34;retry...&#34;)</span>
<span num="25">    }</span>
<span num="26">}</span>
</pre>


</div>

  <ul>

    <li>main线程可能无法看到后台线程对msg和done做的更新</li>

    <li>msg 的修改不是原子操作, main可能看到被修改一半的数据</li>

    <li>多线程环境, 程序结果未知</li>

  </ul>


      </article>



      <article >

        <h3>通过Channel对齐时间参考系</h3>

  <div class="code" >


<pre><span num="5">var msg string</span>
<span num="6"><b>var done = make(chan struct{})</b></span>
<span num="7"></span>
<span num="8">func main() {</span>
<span num="9">    go func() {</span>
<span num="10">        msg = &#34;hello, world&#34;</span>
<span num="11">        <b>done &lt;- struct{}{}</b></span>
<span num="12">    }()</span>
<span num="13"></span>
<span num="14">    <b>&lt;-done</b></span>
<span num="15">    println(msg)</span>
<span num="16">}</span>
</pre>


</div>

  <ul>

    <li>done管道的发送和接收会强制进行一次同步</li>

    <li>此刻, 后台线程内, 满足顺序一致性内存模型, 字符串完成初始化</li>

    <li>此刻, main线程通过同步, 分享到后台线程此刻的字符串状态</li>

    <li>然后, main打印出了初始化之后的字符串</li>

  </ul>


      </article>



      <article >

        <h3>通过sync.Mutex对齐时间参考系</h3>

  <div class="code" >


<pre><span num="9">var msg string</span>
<span num="10"><b>var done sync.Mutex</b></span>
<span num="11"></span>
<span num="12">func main() {</span>
<span num="13">    <b>done.Lock()</b></span>
<span num="14">    go func() {</span>
<span num="15">        msg = &#34;hello, world&#34;</span>
<span num="16">        <b>done.Unlock()</b></span>
<span num="17">    }()</span>
<span num="18"></span>
<span num="19">    <b>done.Lock()</b></span>
<span num="20">    println(msg)</span>
<span num="21">}</span>
</pre>


</div>

  <ul>

    <li>sync.Mutex也是设置时间参考(必须先 Lock, 再 Unlock)</li>

    <li>done.Unlock() 和第二个 done.Lock() 会做一次同步</li>

    <li>但是, 代码可读性没有管道好</li>

  </ul>


      </article>



      <article >

        <h3>带缓存的管道可控制并发数</h3>

  <div class="code" >


<pre><span num="9">func main() {</span>
<span num="10">    var wg sync.WaitGroup</span>
<span num="11">    var limit = make(chan struct{}, 3)</span>
<span num="12">    for i := 0; i &lt; 10; i&#43;&#43; {</span>
<span num="13">        wg.Add(1)</span>
<span num="14">        go func(id int) {</span>
<span num="15">            defer wg.Done()</span>
<span num="16"></span>
<span num="17">            <b>limit &lt;- struct{}{} // len(limit) 小于 cap(limit) 才能进入</b></span>
<span num="18">            <b>defer func(){ &lt;-limit }() // 退出时 len(limit) 减 1</b></span>
<span num="19"></span>
<span num="20">            println(id)</span>
<span num="21">        }(i)</span>
<span num="22">    }</span>
<span num="23">    wg.Wait()</span>
<span num="24">}</span>
</pre>


</div>

  <ul>

    <li>并发程序不仅仅是要运行的更快</li>

    <li>关键是要并发程度可控!</li>

    <li>散步时不要跑的太快...</li>

  </ul>


      </article>



      <article >

        <h3>初始化顺序</h3>

<div class="image">
  <img src="./images/init.png">
</div>

  <ul>

    <li>进入 main 函数之前, 只有一个Goroutine运行</li>

    <li>进入 main 函数之后, 在 init 中启动的 Goroutine 可能会被执行</li>

  </ul>


      </article>



      <article >

        <h3>Goroutine特点</h3>

  <ul>

    <li>由go关键字启动, 是一种轻量级的线程</li>

    <li>以一个很小的栈启动(可能是2KB/4KB), 可以启动很多</li>

    <li>Goroutine栈的大小会根据需要动态地伸缩, 不用担心栈溢出</li>

    <li>m个goroutine运行在n个操作系统线程上, n默认对应CPU核数</li>

    <li>runtime.GOMAXPROCS用于控制当前运行运行正常非阻塞Goroutine的系统线程数目</li>

    <li>发生在用户态, 切换的代价要比系统线程低(切换时只需要保存必要的寄存器)</li>

    <li>Goroutine采用的是半抢占式的协作调度(在函数入口处插入协作代码)</li>

    <li>IO/sleep/runtime.Gosched 均会导致调度</li>

    <li>Goroutine故意设计为没有ID</li>

  </ul>


  <p>
    <b>注意：Goroutine是一种资源，也有泄露的风险！</b>
  </p>



      </article>



      <article >

        <h2>常见的并发模式</h2>

      </article>



      <article >

        <h3>素数筛(01) - 原理</h3>

<div class="image">
  <img src="./images/prime-sieve.png" height="500" width="1000">
</div>


      </article>



      <article >

        <h3>素数筛(02) - 自然数管道</h3>


  <p>
    返回生成自然数序列的管道: 2, 3, 4, ...
  </p>


  <div class="code" contenteditable="true" spellcheck="false">


<pre contenteditable="true" spellcheck="false"><span num="12"><b>func GenerateNatural() chan int {</b></span>
<span num="13">    <b>ch := make(chan int)</b></span>
<span num="14">    go func() {</span>
<span num="15">        for i := 2; ; i&#43;&#43; {</span>
<span num="16">            ch &lt;- i</span>
<span num="17">        }</span>
<span num="18">    <b>}()</b></span>
<span num="19">    return ch</span>
<span num="20">}</span>
</pre>


</div>


      </article>



      <article >

        <h3>素数筛(03) - 素数筛管道</h3>


  <p>
    管道过滤器: 删除能被素数整除的数
  </p>


  <div class="code" contenteditable="true" spellcheck="false">


<pre contenteditable="true" spellcheck="false"><span num="23"><b>func PrimeFilter(in &lt;-chan int, prime int) chan int {</b></span>
<span num="24">    <b>out := make(chan int)</b></span>
<span num="25">    go func() {</span>
<span num="26">        for {</span>
<span num="27">            <b>if i := &lt;-in; i%prime != 0 {</b></span>
<span num="28">                <b>out &lt;- i</b></span>
<span num="29">            }</span>
<span num="30">        }</span>
<span num="31">    }()</span>
<span num="32">    return out</span>
<span num="33">}</span>
</pre>


</div>


      </article>



      <article >

        <h3>素数筛(04) - 管道级联</h3>

  <div class="code" contenteditable="true" spellcheck="false">


<pre contenteditable="true" spellcheck="false"><span num="36">func main() {</span>
<span num="37">    <b>ch := GenerateNatural() // 自然数序列: 2, 3, 4, ...</b></span>
<span num="38">    for i := 0; i &lt; 10; i&#43;&#43; {</span>
<span num="39">        <b>prime := &lt;-ch // 新出现的素数</b></span>
<span num="40">        fmt.Printf(&#34;%v: %v\n&#34;, i&#43;1, prime)</span>
<span num="41">        <b>ch = PrimeFilter(ch, prime) // 基于新素数构造的过滤器</b></span>
<span num="42">    }</span>
<span num="43">}</span>
</pre>


</div>


      </article>



      <article >

        <h3>赢者为王</h3>

  <div class="code" contenteditable="true" spellcheck="false">


<pre contenteditable="true" spellcheck="false"><span num="12">func main() {</span>
<span num="13">    for i := 0; i &lt; 10; i&#43;&#43; {</span>
<span num="14">        <b>ch := make(chan string, 32)</b></span>
<span num="15"></span>
<span num="16">        go func() {</span>
<span num="17">            if _, err := searchByBaidu(&#34;golang&#34;); err == nil {</span>
<span num="18">                <b>ch &lt;- &#34;baidu&#34;</b></span>
<span num="19">            }</span>
<span num="20">        }()</span>
<span num="21">        go func() {</span>
<span num="22">            if _, err := searchByBing(&#34;golang&#34;); err == nil {</span>
<span num="23">                <b>ch &lt;- &#34;bing&#34;</b></span>
<span num="24">            }</span>
<span num="25">        }()</span>
<span num="26"></span>
<span num="27">        <b>fmt.Println(&lt;-ch)</b></span>
<span num="28">    }</span>
<span num="29">}</span>
</pre>


</div>

  <ul>

    <li>启动多个冗余的Goroutine, 返回第一个结果</li>

    <li>虽然可能会有一定的CPU浪费, 但是以最快速度返回结果</li>

  </ul>


      </article>



      <article >

        <h3>监控并发数(01)</h3>


  <div class="code"><pre>type gate chan bool

func (g gate) enter() { g &lt;- true }
func (g gate) leave() { &lt;-g }

func (g gate) Len() int { return len(g) }
func (g gate) Cap() int { return cap(g) }

func (g gate) Idle() bool { return len(g) == 0 }
func (g gate) Busy() bool { return len(g) == cap(g) }

func (g gate) Fraction() float64 {
    return float64(len(g)) / float64(cap(g))
}</pre></div>


  <ul>

    <li>gate 是带缓存的管道</li>

    <li>通过 enter/leave 来控制最大并发数目</li>

    <li>通过利用率来判断并发层度</li>

  </ul>


      </article>



      <article >

        <h3>监控并发数(02)</h3>


  <div class="code"><pre>type gatefs struct {
    fs vfs.FileSystem
    gate
}

func (fs gatefs) Lstat(p string) (os.FileInfo, error) {
    fs.enter()
    defer fs.leave()
    return fs.fs.Lstat(p)
}</pre></div>


  <ul>

    <li>每个函数通过 enter/leave 来控制并发数目</li>

  </ul>


      </article>



      <article >

        <h3>监控并发数(03)</h3>


  <div class="code"><pre>func New(fs vfs.FileSystem, gate chan bool) *gatefs {
    p := &amp;gatefs{fs, gate}
    // 后台监控线程
    go func() {
        for {
            switch {
            case p.gate.Idle():
                // 处理后台任务
            case p.gate.Fraction() &gt;= 0.7:
                // 并发预警
            default:
                time.Sleep(time.Second)
            }
        }
    }()
    return p
}</pre></div>


  <ul>

    <li>根据并发的层度和CPU的压力来调整资源分配</li>

    <li>CPU空闲时, 可以执行一些低级别的任务</li>

    <li>达到一定并发比率时, 提供预警</li>

  </ul>


      </article>



      <article >

        <h3>context包(01)</h3>


  <div class="code"><pre>func worker(ctx context.Context, wg *sync.WaitGroup) error {
    defer wg.Done()

    for {
        select {
        default:
            fmt.Println(&#34;hello&#34;)
        case &lt;-ctx.Done():
            return ctx.Err()
        }
    }
}</pre></div>


  <ul>

    <li>select 多路选择管道</li>

    <li>带 default 分支, 非阻塞</li>

    <li>ctx.Done() 可实现超时和退出操作</li>

  </ul>


      </article>



      <article >

        <h3>context包(02)</h3>


  <div class="code"><pre>func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)

    var wg sync.WaitGroup
    for i := 0; i &lt; 10; i&#43;&#43; {
        wg.Add(1)
        go worker(ctx, &amp;wg)
    }

    time.Sleep(time.Second)
    cancel()

    wg.Wait()
}</pre></div>


  <ul>

    <li>ctx 有超时限制, 并且可主动退出</li>

  </ul>


      </article>



      <article >

        <h3>sync.Map (Go1.9)</h3>

  <div class="code" >


<pre><span num="11">func main() {</span>
<span num="12">    <b>var m sync.Map</b></span>
<span num="13">    for i := 0; i &lt; 3; i&#43;&#43; {</span>
<span num="14">        go func(i int) {</span>
<span num="15">            for j := 0; ; j&#43;&#43; {</span>
<span num="16">                <b>m.Store(i, j)</b></span>
<span num="17">            }</span>
<span num="18">        }(i)</span>
<span num="19">    }</span>
<span num="20">    for i := 0; i &lt; 10; i&#43;&#43; {</span>
<span num="21">        <b>m.Range(func(key, value interface{}) bool {</b></span>
<span num="22">            fmt.Printf(&#34;%d: %d\t&#34;, key, value)</span>
<span num="23">            <b>return true</b></span>
<span num="24">        })</span>
<span num="25">        time.Sleep(time.Second)</span>
<span num="26">        fmt.Println()</span>
<span num="27">    }</span>
<span num="28">}</span>
</pre>


</div>


  <div class="code"><pre>func (m *Map) Load(key interface{}) (value interface{}, ok bool)
func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)</pre></div>



      </article>



      <article >

        <h3>海量请求的处理思路</h3>

  <ul>

    <li>海量请求先存入一个带较大缓冲的管道中, 缓冲大小可能是数千或数万</li>

    <li>构建后台 Goroutine 池, 各自从同一个带缓存的管道取任务执行</li>

  </ul>


      </article>



      <article >

        <h3>并发小结</h3>

  <ul>

    <li>避免 main 提前退出导致其它 Goroutine 被全部杀死</li>

    <li>Goroutine 执行长时间的运算不要永远霸占系统线程(协作式调度)</li>

    <li>Goroutine 要保证在 <b>最快</b> 和 <b>最慢</b> 两个极端场景都是正常的</li>

    <li>Goroutine 不要运行 <b>太快</b>, 也不要 <b>太慢</b></li>

    <li>忘记多线程, 忘记锁, 使用管道来同步</li>

    <li>小心 Goroutine 泄露</li>

  </ul>


      </article>



      <article>
        <h3>Thank you</h3>

          <div class="presenter">


  <p>
    柴树杉(chaishushan{AT}gmail.com)
  </p>

<p class="link"><a href="mailto:chaishushan@gmail.com" target="_blank">chaishushan@gmail.com</a></p><p class="link"><a href="mailto:shushanchai@yunify.com" target="_blank">shushanchai@yunify.com</a></p><p class="link"><a href="https://github.com/chai2010" target="_blank">https://github.com/chai2010</a></p>
          </div>

          <div class="presenter">


  <p>

  </p>


          </div>

      </article>

    </section>

    <div id="help">
      Use the left and right arrow keys or click the left and right
      edges of the page to navigate between slides.<br>
      (Press 'H' or navigate to hide this message.)
    </div>

  </body>
</html>
